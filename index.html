<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Mobile friendly meta tag -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soldier Math Game</title>
  <style>
    /* Basic reset and layout */
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: #f0f0f0;
    }
    #game-container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
      padding: 10px;
    }
    #stats {
      display: flex;
      justify-content: space-around;
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    /* Battlefield area */
    #battlefield {
      position: relative;
      height: 200px;
      background: #a3d977;
      border: 2px solid #333;
      margin-bottom: 10px;
      overflow: hidden;
    }
    .army {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
    }
    /* Player army on left, enemy on right */
    #player-army {
      left: 0;
    }
    #enemy-army {
      right: 0;
    }
    /* Soldier “figure” – can be replaced with images or SVGs */
    .soldier {
      width: 20px;
      height: 20px;
      background: blue;
      border: 1px solid #000;
      margin: 2px;
      border-radius: 3px;
    }
    /* Enemy soldiers in red */
    .enemy .soldier {
      background: red;
    }
    /* Options area */
    #options {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-around;
    }
    #options button {
      font-size: 1.2em;
      padding: 10px;
      flex: 1;
      margin: 5px;
    }
    #timer {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    /* Game over overlay */
    #game-over {
      text-align: center;
      font-size: 2em;
      color: #900;
      padding: 20px;
    }
    /* CSS animations for the marching armies */
    @keyframes marchRight {
      from { transform: translateX(0); }
      to { transform: translateX(50%); }
    }
    @keyframes marchLeft {
      from { transform: translateX(0); }
      to { transform: translateX(-50%); }
    }
    .marching {
      animation-duration: 2s;
      animation-fill-mode: forwards;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Display the current numbers -->
    <div id="stats">
      <div id="player-count">Soldiers: 0</div>
      <div id="enemy-count">Enemy Soldiers: 0</div>
    </div>
    <!-- Battlefield where the armies “march” -->
    <div id="battlefield">
      <div id="player-army" class="army"></div>
      <div id="enemy-army" class="army enemy"></div>
    </div>
    <!-- Two option buttons for the math operations -->
    <div id="options">
      <button id="option1"></button>
      <button id="option2"></button>
    </div>
    <!-- A timer showing how many seconds remain to choose -->
    <div id="timer">Time left: 4</div>
  </div>
  <!-- Game Over screen (initially hidden) -->
  <div id="game-over" style="display: none;">
    Game Over!<br>
    <button id="restart">Restart</button>
  </div>

  <script>
    (function(){
      // Global game variables
      // playerSoldiers is maintained across stages (it persists between stages)
      let playerSoldiers;
      let enemySoldiers;
      let currentStage = 0;
      let timerInterval;
      let timeLeft = 4;
      let stageInProgress = false;
      let chosenOption = null;
      let optionsData = {};
      
      // DOM elements
      const playerCountEl = document.getElementById("player-count");
      const enemyCountEl = document.getElementById("enemy-count");
      const option1El = document.getElementById("option1");
      const option2El = document.getElementById("option2");
      const timerEl = document.getElementById("timer");
      const battlefieldEl = document.getElementById("battlefield");
      const playerArmyEl = document.getElementById("player-army");
      const enemyArmyEl = document.getElementById("enemy-army");
      const gameContainerEl = document.getElementById("game-container");
      const gameOverEl = document.getElementById("game-over");
      const restartEl = document.getElementById("restart");
      
      // Utility: random integer in [min, max]
      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      
      // Update the displayed numbers
      function updateStats() {
        playerCountEl.textContent = "Soldiers: " + playerSoldiers;
        enemyCountEl.textContent = "Enemy Soldiers: " + enemySoldiers;
      }
      
      // Render simple soldier figures
      function renderArmies() {
        // Clear any previous figures.
        playerArmyEl.innerHTML = "";
        enemyArmyEl.innerHTML = "";
        
        // For simplicity, draw 5 soldier blocks per side.
        for(let i = 0; i < 5; i++){
          const sol = document.createElement("div");
          sol.classList.add("soldier");
          playerArmyEl.appendChild(sol);
        }
        for(let i = 0; i < 5; i++){
          const sol = document.createElement("div");
          sol.classList.add("soldier");
          enemyArmyEl.appendChild(sol);
        }
        
        // Reset positions and remove any animation classes.
        playerArmyEl.style.left = "0";
        enemyArmyEl.style.right = "0";
        playerArmyEl.classList.remove("marching");
        enemyArmyEl.classList.remove("marching");
      }
      
      // Begin a new stage.
      function newStage() {
        stageInProgress = true;
        chosenOption = null;
        currentStage++;
        
        // Set enemy soldier count randomly for this stage.
        enemySoldiers = randomInt(10, 40);
        
        // Only initialize playerSoldiers if this is the first stage or after a game over.
        if (playerSoldiers === undefined || playerSoldiers <= 0) {
          playerSoldiers = randomInt(50, 100);
        }
        
        updateStats();
        renderArmies();
        
        // Generate two math operation options.
        // "Good" option: gives a higher result (increases your army enough to overcome the enemy)
        let goodOption = {};
        let opGood = (Math.random() < 0.5) ? "+" : "*";
        if (opGood === "+") {
          // Use an addition that boosts the count above the enemy count.
          let addend = randomInt(enemySoldiers + 1, enemySoldiers + 20);
          goodOption = { op: "+", num: addend, result: (playerSoldiers + addend) - enemySoldiers };
        } else {
          // For multiplication, choose a factor (e.g., 2 or 3)
          let factor = randomInt(2, 3);
          goodOption = { op: "*", num: factor, result: (playerSoldiers * factor) - enemySoldiers };
        }
        
        // Bad option: either subtraction or a weak addition.
        let badOption = {};
        let opBad = (Math.random() < 0.5) ? "-" : "+";
        if (opBad === "-") {
          let subtrahend = randomInt(1, Math.min(playerSoldiers, enemySoldiers + 10));
          badOption = { op: "-", num: subtrahend, result: (playerSoldiers - subtrahend) - enemySoldiers };
        } else {
          let addend = randomInt(1, enemySoldiers);
          badOption = { op: "+", num: addend, result: (playerSoldiers + addend) - enemySoldiers };
        }
        
        // Ensure that the "good" option actually provides a better result.
        if(goodOption.result < badOption.result) {
          let temp = goodOption;
          goodOption = badOption;
          badOption = temp;
        }
        
        // Save the options.
        optionsData = {
          good: goodOption,
          bad: badOption
        };
        
        // Randomly assign the good and bad options to the two buttons.
        if(Math.random() < 0.5) {
          option1El.textContent = optionsData.good.op + optionsData.good.num;
          option2El.textContent = optionsData.bad.op + optionsData.bad.num;
          option1El.dataset.option = "good";
          option2El.dataset.option = "bad";
        } else {
          option1El.textContent = optionsData.bad.op + optionsData.bad.num;
          option2El.textContent = optionsData.good.op + optionsData.good.num;
          option1El.dataset.option = "bad";
          option2El.dataset.option = "good";
        }
        
        // Start a 4‑second timer for the player’s choice.
        timeLeft = 4;
        timerEl.textContent = "Time left: " + timeLeft;
        if(timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(function(){
          timeLeft--;
          timerEl.textContent = "Time left: " + timeLeft;
          if(timeLeft <= 0) {
            clearInterval(timerInterval);
            // If no selection was made in time, default to the bad option.
            if(!chosenOption) {
              chosenOption = optionsData.bad;
              disableOptions();
              startBattleAnimation();
            }
          }
        }, 1000);
        
        // Enable the option buttons.
        option1El.disabled = false;
        option2El.disabled = false;
      }
      
      // Disable the option buttons so the choice cannot be changed.
      function disableOptions() {
        option1El.disabled = true;
        option2El.disabled = true;
      }
      
      // Option button click handlers.
      option1El.addEventListener("click", function(){
        if (!stageInProgress) return;
        if (chosenOption) return;
        let choice = this.dataset.option;
        chosenOption = optionsData[choice];
        disableOptions();
        clearInterval(timerInterval);
        startBattleAnimation();
      });
      
      option2El.addEventListener("click", function(){
        if (!stageInProgress) return;
        if (chosenOption) return;
        let choice = this.dataset.option;
        chosenOption = optionsData[choice];
        disableOptions();
        clearInterval(timerInterval);
        startBattleAnimation();
      });
      
      // Animate the battle: both armies march toward each other.
      function startBattleAnimation() {
        // Add CSS animation classes.
        playerArmyEl.classList.add("marching");
        enemyArmyEl.classList.add("marching");
        playerArmyEl.style.animationName = "marchRight";
        enemyArmyEl.style.animationName = "marchLeft";
        
        // After the 2-second animation, update the player's soldier count.
        setTimeout(function(){
          // Here the player's soldier count is updated based on their chosen math operation.
          playerSoldiers = chosenOption.result;
          if(playerSoldiers < 0) playerSoldiers = 0;
          updateStats();
          
          // Check if the player has lost (soldier count zero or less).
          if(playerSoldiers <= 0) {
            endGame();
          } else {
            // Start a new stage after a brief delay.
            setTimeout(newStage, 1000);
          }
        }, 2000);
      }
      
      // End-of-game: display the Game Over screen.
      function endGame() {
        stageInProgress = false;
        gameContainerEl.style.display = "none";
        gameOverEl.style.display = "block";
      }
      
      // Restart the game.
      restartEl.addEventListener("click", function(){
        // Reset playerSoldiers and other variables.
        playerSoldiers = randomInt(50, 100);
        currentStage = 0;
        gameContainerEl.style.display = "block";
        gameOverEl.style.display = "none";
        newStage();
      });
      
      // Start the first stage when the page loads.
      newStage();
      
    })();
  </script>
</body>
</html>
