<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Mobile friendly meta tag -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soldier Math Game</title>
  <style>
    /* Basic page reset and layout */
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: #f0f0f0;
    }
    #game-container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
      padding: 10px;
    }
    #stats {
      display: flex;
      justify-content: space-around;
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    /* Battlefield area */
    #battlefield {
      position: relative;
      height: 200px;
      background: #a3d977;
      border: 2px solid #333;
      margin-bottom: 10px;
      overflow: hidden;
    }
    .army {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-wrap: wrap;
      width: 45%;
    }
    /* Position player on left and enemy on right */
    #player-army {
      left: 0;
      justify-content: flex-start;
    }
    #enemy-army {
      right: 0;
      justify-content: flex-end;
    }
    /* Soldier “figure” styling */
    .soldier {
      width: 20px;
      height: 20px;
      margin: 2px;
      transition: opacity 0.3s;
    }
    .soldier svg {
      width: 100%;
      height: 100%;
    }
    /* Color each soldier according to side */
    .player-soldier svg {
      fill: blue;
    }
    .enemy-soldier svg {
      fill: red;
    }
    .faded {
      opacity: 0;
    }
    /* Options area */
    #options {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-around;
    }
    #options button {
      font-size: 1.2em;
      padding: 10px;
      flex: 1;
      margin: 5px;
    }
    #timer {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    /* Game Over overlay */
    #game-over {
      text-align: center;
      font-size: 2em;
      color: #900;
      padding: 20px;
    }
    /* CSS animations: Both armies march toward each other */
    @keyframes marchRight {
      from { transform: translateX(0); }
      to { transform: translateX(50%); }
    }
    @keyframes marchLeft {
      from { transform: translateX(0); }
      to { transform: translateX(-50%); }
    }
    .marching {
      animation-duration: 2s;
      animation-fill-mode: forwards;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Display current counts -->
    <div id="stats">
      <div id="player-count">Soldiers: 0</div>
      <div id="enemy-count">Enemy Soldiers: 0</div>
    </div>
    <!-- Battlefield: Two army containers -->
    <div id="battlefield">
      <div id="player-army" class="army"></div>
      <div id="enemy-army" class="army"></div>
    </div>
    <!-- Option buttons for the math operations -->
    <div id="options">
      <button id="option1"></button>
      <button id="option2"></button>
    </div>
    <!-- Timer display -->
    <div id="timer">Time left: 4</div>
  </div>
  <!-- Game Over screen -->
  <div id="game-over" style="display: none;">
    Game Over!<br>
    <button id="restart">Restart</button>
  </div>

  <script>
    (function(){
      // Global game variables
      let playerSoldiers; // persists across stages (max 200)
      let enemySoldiers;
      let currentStage = 0;
      let timerInterval;
      let timeLeft = 4;
      let stageInProgress = false;
      let chosenOption = null;
      let optionsData = {};
      
      // DOM elements
      const playerCountEl = document.getElementById("player-count");
      const enemyCountEl = document.getElementById("enemy-count");
      const option1El = document.getElementById("option1");
      const option2El = document.getElementById("option2");
      const timerEl = document.getElementById("timer");
      const battlefieldEl = document.getElementById("battlefield");
      const playerArmyEl = document.getElementById("player-army");
      const enemyArmyEl = document.getElementById("enemy-army");
      const gameContainerEl = document.getElementById("game-container");
      const gameOverEl = document.getElementById("game-over");
      const restartEl = document.getElementById("restart");
      
      // Utility: return random integer in [min, max]
      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      
      // Update the text stats on screen
      function updateStats() {
        playerCountEl.textContent = "Soldiers: " + playerSoldiers;
        enemyCountEl.textContent = "Enemy Soldiers: " + enemySoldiers;
      }
      
      // Create a soldier DOM element with inline SVG.
      function createSoldier(side) {
        const div = document.createElement("div");
        div.classList.add("soldier");
        if(side === "player"){
          div.classList.add("player-soldier");
        } else if(side === "enemy"){
          div.classList.add("enemy-soldier");
        }
        // A simple SVG that resembles a soldier figure.
        div.innerHTML = `<svg viewBox="0 0 24 24">
          <path d="M12 2C10.343 2 9 3.343 9 5s1.343 3 3 3 3-1.343 3-3-1.343-3-3-3zm0 8c-2.206 0-4 
          1.794-4 4v5h8v-5c0-2.206-1.794-4-4-4z"/>
        </svg>`;
        return div;
      }
      
      // Render the armies with a given count.
      // For the player, count should be the intermediate value (after math op, capped at 200).
      // For enemy, count is enemySoldiers.
      function renderArmies(playerCount, enemyCount) {
        playerArmyEl.innerHTML = "";
        enemyArmyEl.innerHTML = "";
        for(let i = 0; i < playerCount; i++){
          playerArmyEl.appendChild(createSoldier("player"));
        }
        for(let i = 0; i < enemyCount; i++){
          enemyArmyEl.appendChild(createSoldier("enemy"));
        }
        // Reset positions and remove any prior animations.
        playerArmyEl.style.left = "0";
        enemyArmyEl.style.right = "0";
        playerArmyEl.classList.remove("marching");
        enemyArmyEl.classList.remove("marching");
      }
      
      // Begin a new stage.
      function newStage() {
        stageInProgress = true;
        chosenOption = null;
        currentStage++;
        
        // Determine enemy soldier count (for visual effect, a modest number)
        enemySoldiers = randomInt(10, 40);
        updateStats();
        
        // Render the current player soldiers (from previous stage) as icons.
        renderArmies(playerSoldiers, enemySoldiers);
        
        // Generate two math operation options.
        // We compute an “intermediate” value then a “final” value after cancellation.
        // For the good option, choose an operator and operand that yields a higher final result.
        let goodOption = {};
        let opGood = (Math.random() < 0.5) ? "+" : "*";
        if(opGood === "+") {
          // Choose an addend that increases the count well above enemy count.
          let addend = randomInt(enemySoldiers + 1, enemySoldiers + 20);
          // Final will be: (playerSoldiers + addend) capped at 200, then minus enemySoldiers.
          let intermediate = Math.min(playerSoldiers + addend, 200);
          goodOption = { op: "+", num: addend, intermediate: intermediate, final: intermediate - enemySoldiers };
        } else {
          // Multiplication option.
          let factor = randomInt(2, 3);
          let intermediate = Math.min(playerSoldiers * factor, 200);
          goodOption = { op: "*", num: factor, intermediate: intermediate, final: intermediate - enemySoldiers };
        }
        
        // Bad option: subtraction or weak addition.
        let badOption = {};
        let opBad = (Math.random() < 0.5) ? "-" : "+";
        if(opBad === "-") {
          let subtrahend = randomInt(1, Math.min(playerSoldiers, enemySoldiers + 10));
          let intermediate = playerSoldiers - subtrahend; // no cap needed if reducing
          badOption = { op: "-", num: subtrahend, intermediate: intermediate, final: intermediate - enemySoldiers };
        } else {
          // Weak addition.
          let addend = randomInt(1, enemySoldiers);
          let intermediate = Math.min(playerSoldiers + addend, 200);
          badOption = { op: "+", num: addend, intermediate: intermediate, final: intermediate - enemySoldiers };
        }
        
        // Ensure that the "good" option gives a higher final result.
        if(goodOption.final < badOption.final){
          let temp = goodOption;
          goodOption = badOption;
          badOption = temp;
        }
        
        optionsData = { good: goodOption, bad: badOption };
        
        // Randomly assign the good and bad options to the two buttons.
        if(Math.random() < 0.5){
          option1El.textContent = optionsData.good.op + optionsData.good.num;
          option2El.textContent = optionsData.bad.op + optionsData.bad.num;
          option1El.dataset.option = "good";
          option2El.dataset.option = "bad";
        } else {
          option1El.textContent = optionsData.bad.op + optionsData.bad.num;
          option2El.textContent = optionsData.good.op + optionsData.good.num;
          option1El.dataset.option = "bad";
          option2El.dataset.option = "good";
        }
        
        // Start a 4‑second timer for making a choice.
        timeLeft = 4;
        timerEl.textContent = "Time left: " + timeLeft;
        if(timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(function(){
          timeLeft--;
          timerEl.textContent = "Time left: " + timeLeft;
          if(timeLeft <= 0){
            clearInterval(timerInterval);
            if(!chosenOption){
              // If no selection is made, automatically choose the bad option.
              chosenOption = optionsData.bad;
              disableOptions();
              startBattleAnimation();
            }
          }
        }, 1000);
        
        // Enable buttons.
        option1El.disabled = false;
        option2El.disabled = false;
      }
      
      // Disable option buttons to prevent further selection.
      function disableOptions(){
        option1El.disabled = true;
        option2El.disabled = true;
      }
      
      // Handle option button clicks.
      option1El.addEventListener("click", function(){
        if(!stageInProgress || chosenOption) return;
        chosenOption = optionsData[this.dataset.option];
        disableOptions();
        clearInterval(timerInterval);
        startBattleAnimation();
      });
      
      option2El.addEventListener("click", function(){
        if(!stageInProgress || chosenOption) return;
        chosenOption = optionsData[this.dataset.option];
        disableOptions();
        clearInterval(timerInterval);
        startBattleAnimation();
      });
      
      // Start the battle animation.
      // Here we apply the chosen math operation, re-render the armies with the new (intermediate) numbers,
      // animate both armies marching toward each other, and then start the collision animation.
      function startBattleAnimation(){
        // Calculate the new numbers:
        // intermediate = (playerSoldiers op operand) capped at 200,
        // final = intermediate - enemySoldiers.
        let intermediate;
        if(chosenOption.op === "+"){
          intermediate = playerSoldiers + chosenOption.num;
        } else if(chosenOption.op === "*"){
          intermediate = playerSoldiers * chosenOption.num;
        } else if(chosenOption.op === "-"){
          intermediate = playerSoldiers - chosenOption.num;
        }
        intermediate = Math.min(intermediate, 200);
        let finalCount = intermediate - enemySoldiers;
        chosenOption.intermediate = intermediate;
        chosenOption.final = finalCount;
        
        // Re-render armies using the new numbers.
        renderArmies(intermediate, enemySoldiers);
        
        // Animate marching: both armies move toward the center.
        playerArmyEl.classList.add("marching");
        enemyArmyEl.classList.add("marching");
        playerArmyEl.style.animationName = "marchRight";
        enemyArmyEl.style.animationName = "marchLeft";
        
        // After the march (2 seconds), animate the cancellation effect.
        setTimeout(function(){
          animateCollision(chosenOption.intermediate, enemySoldiers, chosenOption.final);
        }, 2000);
      }
      
      // Animate collision: soldiers from both sides cancel each other out.
      // The function gradually “fades” out a pair of soldier icons every 50ms.
      function animateCollision(intermediate, enemyCount, finalCount) {
        let playerIcons = Array.from(playerArmyEl.querySelectorAll('.soldier'));
        let enemyIcons = Array.from(enemyArmyEl.querySelectorAll('.soldier'));
        let cancelCount = Math.min(enemyCount, intermediate); // normally equals enemyCount.
        let i = 0;
        let interval = setInterval(function(){
          if(i < cancelCount){
            if(playerIcons[i]){
              playerIcons[i].classList.add("faded");
            }
            if(enemyIcons[i]){
              enemyIcons[i].classList.add("faded");
            }
            i++;
          } else {
            clearInterval(interval);
            // After cancellation, re-render the player's army to show only the survivors.
            setTimeout(function(){
              // Update player's soldier count. If finalCount is <= 0, game over.
              playerSoldiers = finalCount;
              // Ensure it never goes above 200.
              playerSoldiers = Math.min(playerSoldiers, 200);
              updateStats();
              // Re-render the player's army to show only survivors.
              playerArmyEl.innerHTML = "";
              for(let j = 0; j < Math.max(playerSoldiers,0); j++){
                playerArmyEl.appendChild(createSoldier("player"));
              }
              // Clear the enemy side.
              enemyArmyEl.innerHTML = "";
              
              // Check for game over.
              if(playerSoldiers <= 0){
                endGame();
              } else {
                setTimeout(newStage, 1000);
              }
            }, 500);
          }
        }, 50);
      }
      
      // End the game and show the Game Over screen.
      function endGame(){
        stageInProgress = false;
        gameContainerEl.style.display = "none";
        gameOverEl.style.display = "block";
      }
      
      // Restart the game.
      restartEl.addEventListener("click", function(){
        playerSoldiers = randomInt(50, 100);
        currentStage = 0;
        gameContainerEl.style.display = "block";
        gameOverEl.style.display = "none";
        newStage();
      });
      
      // Start the game on page load.
      playerSoldiers = randomInt(50, 100);
      updateStats();
      newStage();
      
    })();
  </script>
</body>
</html>
